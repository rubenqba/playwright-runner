# Repository Guidelines

## Project Structure & Module Organization

- Monorepo managed by the Nest CLI with sources split between `apps/` and `libs/` (see `nest-cli.json`).
- The only runtime application today is the API in `apps/api/src`. Its internal layout groups concerns under:
  - `common/`: reusable filters, helpers, and Mongoose plugins.
  - `config/`: configuration factories (`mongodb.config.ts`, `redis.config.ts`, `storage.config.ts`) and the Zod-driven `env.schema.ts`.
  - `executions/`: Bull queue wiring (`test-execution`), controller, processor, Zod schemas, and executor services responsible for running Playwright jobs and persisting results.
  - `recordings/`: REST controllers and service backed by Mongo collections that manage captured UI recordings and trigger executions.
  - `storage/`: abstraction over filesystem and MinIO providers, DTOs, and the REST controller that exposes stored execution artifacts.
  - `playwright/`: utility helpers (e.g., translating recordings into Playwright specs) and the module shell.
- Shared types, Zod schemas, and a lightweight Nest module live in `libs/shared/src` and are consumed through the `@cmx-replayer/shared` alias. The API also imports local code through the `@/` alias that resolves to `apps/api/src`.
- Runtime artifacts generated by executors are written to `test-outputs/`; keep it out of version control or prune it after large runs.
- Compiled output lands in `dist/` (`dist/apps/api` for the API, `dist/libs` for shared code); never edit generated files directly.
- `compose.yml` provisions the supporting services (MongoDB, Redis, MinIO) relying on local `.data/` volumes and `.data/env.local` for MinIO credentials.

## Build, Test, and Development Commands

- Install dependencies with `pnpm install` (pnpm v9+ recommended).
- Run the API in watch mode via `pnpm start:dev`; production-style boots use `pnpm start`.
- Build artifacts with `pnpm build`, which compiles the API to `dist/apps/api` and the shared library to `dist/libs/shared`.
- The generated `dist` entry point is `dist/apps/api/main.js`. The `start:prod` script still points at `dist/apps/application/main`, so update that script or run `node dist/apps/api/main` manually after a build.
- Lint and format through `pnpm lint` (ESLint v9 using the flat config in `eslint.config.mjs`) and `pnpm format` (Prettier targets `apps/**/*.ts` and `libs/**/*.ts`).
- Tests use Jest with the configuration embedded in `package.json`; run them with `pnpm test`, `pnpm test:watch`, or `pnpm test:cov` (coverage writes to `coverage/`).
- The `pnpm test:e2e` script currently references `apps/application/test/jest-e2e.json`, which does not exist. Create a matching harness under `apps/api/test/` or update the script before relying on e2e runs.

## NestJS Framework Practices

- Follow the full best-practice playbook in `.github/instructions/nestjs.instructions.md`. That document applies to all TypeScript/JavaScript code and expands on dependency injection, modular design, testing, and security expectations.
- Keep controllers slim: route wiring and request/response orchestration live in controllers, while business logic belongs in injectable services. Use constructor injection for dependencies and prefer interface-based providers when you plan to mock them.
- Embrace the modular architecture: feature modules should expose only what they need (`exports`), import dependencies deliberately, and avoid circular references. Use Nest’s `forRoot`/`forFeature` patterns where configuration is required.
- Validation should rely on Zod schemas (`nestjs-zod` pipes, `createZodDto`). Create separate schemas per operation (create/update/query) and reuse them across DTOs, config parsing, and swagger metadata.
- Consistent naming is required: `*.controller.ts`, `*.service.ts`, `*.module.ts`, `*.schema.ts`, DTOs in `*.dto.ts`, guards in `*.guard.ts`, etc., in line with the instructions file and existing code.
- Configuration is centralized through `@nestjs/config` with validation at startup. Extend the factories in `apps/api/src/config/` and reuse the shared `env.schema.ts` patterns when introducing new environment variables.
- Handle errors through Nest filters (`HttpExceptionFilter`) and the base logger. Avoid manual instantiation of providers—let Nest’s DI container manage lifecycle to keep testing and overrides simple.

## Coding Style & Naming Conventions

- The repository targets TypeScript 5 with `module`/`moduleResolution` set to `NodeNext`; stick to ES module syntax and respect path aliases declared in the project `tsconfig.json` files.
- Use Nest naming patterns: modules end with `Module`, injectable classes end with `Service` or match their role (`Controller`, `Processor`), and injection tokens such as `STORAGE_PROVIDER` remain symbols.
- Validation leans on Zod (`createZodDto`, `nestjs-zod` pipes, and config parsers). Prefer introducing new DTOs and schemas there rather than using class-validator.
- Logging and error handling follow Nest’s `Logger` plus domain-specific helpers (e.g., `isError`); keep new logs structured and avoid leaking secrets.
- Prettier defaults apply (two spaces, single quotes, trailing commas). Avoid introducing alternative formatting or non-ASCII characters unless required by existing content.

## Testing Guidelines

- Unit tests live alongside their subjects as `*.spec.ts`. Only `libs/shared/src/shared.service.spec.ts` exists today—mirror that placement for new specs in either `apps/api` or `libs/shared`.
- The Jest config registers both `apps/` and `libs/` as roots and treats `.ts` as ES modules. Use `@nestjs/testing` to bootstrap modules and mock external services (Mongo, Redis, MinIO) when adding server tests.
- Coverage reports land in `coverage/` via `pnpm test:cov`. Ensure new features include assertions around their Zod schemas and queue interactions to keep runtime failures detectable.
- No working e2e suite is present yet. If end-to-end coverage is required, scaffold it under `apps/api/test/` and update `pnpm test:e2e` accordingly.
- When following the Nest instructions doc, keep tests focused on business logic rather than framework internals, mock external integrations, and ensure teardown of resources to avoid leaks.

## Commit & Pull Request Guidelines

- Follow Conventional Commits (`feat: ...`, `fix: ...`, etc.) to keep history searchable.
- Validate changes with `pnpm lint` and `pnpm test` before opening a PR; include build or manual execution notes when touching execution flows or storage providers.
- Provide PR descriptions that explain behavioural changes, reference tracking tickets, and attach logs or screenshots for workflow or API surface changes.
- Call out configuration or infrastructure updates (new env vars, Docker compose changes, storage requirements) so deployment steps remain obvious.

## Security & Configuration Tips

- Centralise configuration through the `ConfigModule` in `apps/api/src/app.module.ts`. It loads `.env.local` before `.env` and wires in the factories from `apps/api/src/config/*`.
- Required environment variables include `MONGODB_URI` (plus optional `MONGODB_USERNAME`/`MONGODB_PASSWORD`), Redis connection settings (`REDIS_HOST`, `REDIS_PORT`, etc.), and storage parameters.
- `storage.config.ts` enforces provider-specific requirements via Zod: filesystem storage needs `FILESYSTEM_BASE_PATH`, `FILESYSTEM_BASE_URL`, and `FILESYSTEM_SECRET_KEY`, while MinIO requires endpoint, port, credentials, and `MINIO_BUCKET`.
- The Playwright executors write temporary code and artifacts under `test-outputs/`; scrub sensitive data before sharing artifacts and ensure the directory is excluded from production images.
- Never commit `.env` files, the `.data/` directory used by Docker compose, or test result archives. Document any secrets or credentials in internal runbooks instead of this repository.
